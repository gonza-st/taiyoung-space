### Message Queue를 사용하는 이유

- 비동기 메시지를 사용하여 다른 응용프로그램 사이에 데이터를 송수신
- 클라이언트에 대한 동기 처리는 병목의 요인이므로 비동기로 처리 해도 될 영역에 대해서는 큐를 통해 분리해서 처리한다
- 결국 분산환경에서 응용프로그램들을 분리하고 독립적으로 확장하기 위해서 사용, 기능 별로 모듈 구성이 용이
- 요청에 대한 응답을 기다릴 필요가 없기 때문에 각 영역의 역할만 신경쓰면 된다. 어플리케이션 레벨에서 분리 할 수 있다
- 데이터를 메모리 대신에 디스크에 저장하여 데이터 유실을 방지한다.
    - 즉시 처리하지 않아도 나중에 다시 처리가 가능하다
    - 메시지 영구 저장, 메시지 확인, 장애 복구 메커니즘을 통해 메시지의 신뢰성을 보장한다
- 확장성: 여러 노드에 걸쳐 쉽게 확장할 수 있어 높은 가용성을 제공하며, 필요에 따라 메시지를 클러스터링 하거나 페더레이션 방식으로 확장할 수 있다
- 유연성: 다양한 exchange 유형과 라우팅 규칙을 지원하여 메시지를 효과적으로 라우팅 하고 관리할 수 있다
    - 광범위한 프로토콜 지원: 기본적으로 AMQP 를 사용하지만, STOMP, MQTT, HTTP 등을 포함한 다양한 프로토콜을 지원한다
    - 풍부한 클라이언트 라이브러리: Java, Python, Ruby, 등 다양한 언어로 클라이언트 라이브러리를 제공하여 다양한 어플리케이션에서 사용할 수 있다

### AMQP 를 쓰는 이유

이전에도 상용화된 MQ제품들은 많았지만, 한가지 문제가 있다면 대부분 플랫폼 종속적인 제품들이었기 때문에 서로 다른 이기종간에 메시지를 교환하기 위해서는 메시지 포맷 컨버전을 위한 메시지 브릿지를 이용하거나 ( 속도 저하 발생 ) 시스템 자체를 통일시켜야 하는 불편함과 비효율성이 있었다. 즉 AMQP의 목적은 서로 다른 시스템간에 ( 비용/기술/시간적인 측면에서 ) 최대한 효율적인 방법으로 메시지를 교환하기 위한 MQ 프로토콜로 아래와 같은 특징이 있다. 

- 모든 broker 들은 똑같은 방식으로 동작할 것
- 모든 client들은 똑같은 방식으로 동작할 것
- 네트워크상으로 전송되는 명령어들의 표준화
- 프로그래밍 언어 중립적

### Routing Model Component

AMQP의 라우팅 모델은 3가지의 중요한 component들로 구성되어 있다 

- Exchange → Publisher로 부터 수신한 메시지를 적절한 큐 또는 다른 exchange로 분배하는 라우터의 기능을 한다
- Queue → 일반적으로 알고있는 큐, 메모리나 디스크에 메시지를 저장하고, 그것을 consumer에게 전달하는 역할을 한다
- Binding → exchange와 큐와의 관계를 정의한 일종의 라우팅 테이블이다. 같은 큐가 여러개의 exchange에 bind될 수 있고, 하나의 exchange에 여러개의 큐가 binding 될 수 있다.

- Routing Key → 라우팅 키는 발행된 메시지와 큐가 라우팅 테이블을 통해 매칭되는 키를 뜻한다. Publisher 혹은 producer로 칭하는 송신부에서 송신한 메시지 헤더에 포함되는 것으로 일종의 가상 주소라고 생각하면 된다.

## RabbitMQ 주요 용어 정리

### Producer (생산자)

- 메시지를 생성하고 RabbitMQ에 전송하는 애플리케이션
- 특정 Exchange에 메시지를 전송하고, Exchange는 메시지를 라우팅하여 큐에 배치

### Exchange

- Producer로부터 받은 메시지를 큐에 전달
- **Exchange 유형**:
    - **Direct**: 특정 라우팅 키와 정확히 일치하는 큐에 메시지를 전송
    - **Fanout**: 모든 큐에 메시지를 브로드캐스트
    - **Topic**: 라우팅 키 패턴을 기반으로 특정 큐에 메시지를 전달
    - **Headers**: 메시지 헤더 속성에 따라 메시지를 라우팅
- 메시지가 Exchange로 전송될 때, Routing Key가 함께 전달됨

### Routing Key

- 메시지를 전송할 때 Producer가 Exchange에 전달하는 키
- Exchange는 이 Routing Key를 참고하여 어떤 큐에 메시지를 전달할지 결정

### Queue

- 메시지를 일시적으로 저장하는 버퍼 역할
- RabbitMQ의 큐는 **FIFO (First In, First Out)** 방식으로 동작하며, 메시지가 소비자에게 전달될 때까지 보관
- 여러 Consumer가 구독(수신)할 수 있으며, 메시지는 큐에 들어온 순서대로 전달
- **비동기적**으로 동작하며, 여러 컨슈머가 동시에 메시지를 소비할 수 있음
- 동일한 메시지를 수신하려면 **Fanout Exchange 방식**을 사용해야 함

### Binding

- Exchange와 큐 간의 관계를 정의
- 바인딩은 메시지를 라우팅할 때 어떤 조건으로 큐에 보낼지 정의하며, **Binding Key**가 사용됨
- Binding Key와 Routing Key가 일치하면 해당 큐로 메시지가 전달됨 (패턴 매칭 가능)

### Consumer (소비자)

- 큐에서 메시지를 가져와 처리하는 애플리케이션
- RabbitMQ는 여러 소비자에게 메시지를 **로드 밸런싱**할 수 있음
- Consumer는 메시지를 받아 처리한 후 메시지에 대한 확인(**ACK, acknowledgment**)을 브로커에 전송
- 메시지 처리가 실패하면, 브로커는 메시지를 재전송하거나 다른 Consumer에게 전달 가능

### Message Acknowledgment (메시지 확인)

- 메시지가 성공적으로 처리되었음을 RabbitMQ에 알리는 과정
- Consumer가 메시지를 성공적으로 처리하지 못하면, 메시지를 다시 큐에 넣어 다른 Consumer가 처리할 수 있음

```kotlin
이 과정을 간략하게 도식화 한다면 
1. Producer가 메시지와 Routing Key를 Exchange에게 전송. 
2. Exchange가 Routing Key를 사용해 Binding Key가 일치하는 큐에 메시지를 라우팅 
3. Consumer가 큐에서 메시지를 가져와 처리하고, 성공적으로 처리되었음을 ack로 rabbitmq에 알림 

```

<img src="./image/mq1.png" width="90%" height="30%" title="px(픽셀) 크기 설정" alt="mq1"></img>

## 추가 용어

### Prefetch Count (프리페치 카운트)

- 소비자가 받을 수 있는 최대 메시지 수를 설정
- 한 번에 많은 양의 메시지를 처리하지 않도록 하여 소비자의 성능 최적화

### Virtual Host (가상 호스트)

- RabbitMQ 서버 내의 논리적인 구획으로, 메시지 큐, 익스체인지, 사용자 권한 등을 구분
- 하나의 RabbitMQ 서버 내에 여러 개의 가상 호스트를 설정하여 서로 다른 애플리케이션의 메시지를 격리 가능

### Dead Letter Queue (DLQ)

- 메시지가 처리되지 못하거나 유효 기간이 지난 경우 별도의 큐로 이동하는 구조

## Exchange 유형에 따른 처리 흐름

<img src="./image/mq2.png" width="90%" height="30%" title="px(픽셀) 크기 설정" alt="mq2"></img>

### Direct Exchange

Direct Exchange는 메시지가 라우팅 키에 따라 특정 큐로 하나씩 전달되는 방식이다. 메시지를 발행할 때 사용하는 라우팅 키와 동일한 키로 익스체인지에 바인딩 된 모든 큐에 메시지를 전달한다. 해당 라우팅 키와 일치하는 큐에만 메시지가 전달되는 방식이기 때문에 Direct Exchagne 라고 한다. 

사용 예시 : 주문에 따른 상태 지시 

활용: 주문 상태별로 라우팅 키를 정의하고, 각 상태에 해당하는 큐가 메시지를 받는다. 매핑이 정확하게 되는 한개의 키만 있기 때문에 1:1 로 가능할 거 같은데, 하나의 라우팅 키에 여러 큐가 바인딩 될 수 있기 때문에 1:N 매칭또한 가능하다. 

- 메시지가 명확하게 특정 큐로 전달되어야 할 때
- 큐마다 고유한 라우팅 규칙을 적용하여 메시지를 분류해야 할 때
- 활용 예시: 주문 상태 처리, 결제 처리, 사용자 알림 시스템 등..

### Topic Exchange

Topic Exchange는 라우팅 키를 패턴 기반으로 정의하여 메시지를 여러 큐에 유연하게 전달할 수 있는 방식이다. 라우팅 키에 와일드 카드 ( *, # ) 매칭을 사용하여 더 복잡한 라우팅이 가능 하다. 

- 와일드 카드 `*` 의 경우 하나의 단어를 대체하는 의미로 `log.info`, `log.warn`, `log.error` 와 같은 패턴의 메시지를 수신할 때 `log.*` 로 `info, warn, error` 를 다 수신할 수 있게 만들어 준다.
- #의 경우 0개 이상의 단어를 대체하므로 `app.order.success` `app.payment.success` 와 같은 라우팅 키를 `app.#.success`로 다 수신할 수 있다.

사용 예시 : 동적이고 유연한 라우팅이 필요할 때 ( 로그 수집, 이벤트 기반 모니터링 등 ) 

### Fanout Exchange

Fanout Exchange는 브로드캐스트 방식으로 메시지를 모든 바인딩된 큐에 전달한다. 한번의 메시지 발행으로 모든 큐가 동일한 메시지를 받는다. 

사용예시: 이벤가 발생하면 모든 서비스가 동일한 메시지를 받는 서비스에서 유영하다. ( 시스템 점검 공지 등 ) 

### Headers Exchange

메시지의 속성(헤더)에 기반한 복잡한 라우팅이 필요할 때 

사용예시: 다국어 서비스, 고객의 등급별 혜택 알림 

메시지 헤더에 `language: "ko"` `language: "en"` 등의 값을 설정하여 헤더 기반 라우팅을 수행 

- `language: "ko"` 로 설정된 메시지는 한국어 이메일 서비스에서 처리
- `language: "en"` 으로 설정된 메시지는 영어 이메일 서비스에서 처리

### 메시지 전송 단계별 프로세스
<img src="./image/mq3.png" width="90%" height="30%" title="px(픽셀) 크기 설정" alt="mq3"></img>

1. 메시지 송신 ( Product → Broker ) 
- Producer가 RabbitMQ Broker로 메시지를 송신, 이때 메시지는 큐에 저장되며, 익스체인지와 바인딩 설정에 따라 적절한 큐로 라우팅

1. 메시지 전달 ( Broker → Consumer ) 
- Broker는 큐에 있는 메시지를 Consumer에게 전달. Consumer는 큐에서 메시지를 가져가거나(pooling) 메시지를 푸시(push) 받는 방식으로 수신 ( 기본적으로 rabbitmq 기본 config 는 push )

1. 메시지 확인 (ACK) 또는 거절 (NACK)
- ACK: Consumer가 메시지를 성공적으로 처리한 후 Broker에 ACK 를 전송. 이 경우 Broker는 해당 메시지를 큐에서 제거하고 Producer에게 Message Acknowledged 응답을 전송
- NACK: Consumer가 메시지 처리에 실패하거나 메시지를 거절할 경우 NACK을 전송. NACK에는 메시지를 다시 큐로 보내야 할지 또는 폐기해야 할지 설정이 가능
    - 재전송 요청: 메시지를 다시 큐로 보내고 재처리 할 수 있도록 설정
    - 폐기: 메시지를 큐에서 제거하고, 폐기 처리
- Consumer가 메시지를 NACK하면 Broker는 Producer에게 Message Rejected응답 을 전송

1. Producer에 응답 
- Producer 가 Publisher Confirms를 활성한 경우, Broker는 ACK 또는 NACK 결과를 Producer에게 전송
- ACK를 받은 경우 메시지가 성공적으로 소비된 것으로 간주 되며, NACK 를 받은 경우 Producer는 메시지 실패를 기록하거나 재전송